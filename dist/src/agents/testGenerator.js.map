{"version":3,"file":"testGenerator.js","sourceRoot":"","sources":["../../../src/agents/testGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from \"fs\";\nimport path from \"path\";\nimport { askAI } from \"./aiClient.js\";\nimport { createLogger, format, transports } from \"winston\";\n\n/**\n * Options for test generation\n */\ninterface TestGeneratorOptions {\n  /** Custom test template to use (optional) */\n  template?: string;\n  /** Custom test file extension (default: .spec.ts) */\n  fileExtension?: string;\n  /** Directory to save tests (relative to project root) */\n  outputDir?: string;\n  /** Whether to validate generated test syntax (default: true) */\n  validateSyntax?: boolean;\n  /** Whether to format the generated test (default: true) */\n  formatCode?: boolean;\n  /** AI model temperature for generation (default: 0.7) */\n  temperature?: number;\n}\n\n/**\n * Result of test generation\n */\ninterface GeneratedTest {\n  /** Path to the generated test file */\n  filePath: string;\n  /** The generated test content */\n  content: string;\n  /** Any validation warnings */\n  warnings?: string[];\n  /** Generation metadata */\n  metadata: {\n    /** When the test was generated */\n    timestamp: string;\n    /** Original prompt used */\n    prompt: string;\n    /** Options used for generation */\n    options: Required<TestGeneratorOptions>;\n  };\n}\n\nconst DEFAULT_OPTIONS: Required<TestGeneratorOptions> = {\n  template: '',\n  fileExtension: '.spec.ts',\n  outputDir: 'tests/generated',\n  validateSyntax: true,\n  formatCode: true,\n  temperature: 0.7\n} as const;\n\n// Configure logger\nconst logger = createLogger({\n  format: format.combine(\n    format.timestamp(),\n    format.colorize(),\n    format.printf(({ timestamp, level, message }) => {\n      return `${timestamp} [${level}]: ${message}`;\n    })\n  ),\n  transports: [\n    new transports.Console(),\n    new transports.File({ filename: 'error.log', level: 'error' }),\n    new transports.File({ filename: 'test-generator.log' })\n  ]\n});\n\n/**\n * Custom error for test generation failures\n */\nexport class TestGenerationError extends Error {\n  constructor(message: string, public readonly details?: unknown) {\n    super(message);\n    this.name = 'TestGenerationError';\n  }\n}\n\n/**\n * Generates a test file from a prompt\n * @param prompt Test scenario description\n * @param testName Name of the test (will be used in filename)\n * @param options Generation options\n * @returns Information about the generated test\n * @throws {TestGenerationError} If test generation or validation fails\n */\nexport async function generateTest(\n  prompt: string,\n  testName: string,\n  options: TestGeneratorOptions = {}\n): Promise<GeneratedTest> {\n  const opts: Required<TestGeneratorOptions> = { ...DEFAULT_OPTIONS, ...options };\n  const warnings: string[] = [];\n  const startTime = Date.now();\n\n  try {\n    // Validate inputs\n    validateInputs(prompt, testName);\n\n    // Ensure output directory exists\n    const testDir = await ensureOutputDirectory(opts.outputDir);\n\n    // Generate test content\n    let content = await generateTestContent(prompt, opts);\n    \n    // Validate syntax if requested\n    if (opts.validateSyntax) {\n      const syntaxIssues = validateTestSyntax(content);\n      warnings.push(...syntaxIssues);\n    }\n\n    // Format code if requested\n    if (opts.formatCode) {\n      content = await formatTestCode(content);\n    }\n\n    // Write test file\n    const testFilePath = await writeTestFile(testDir, testName, content, opts);\n    const duration = Date.now() - startTime;\n\n    logger.info(`Test generated successfully in ${duration}ms: ${path.relative(process.cwd(), testFilePath)}`);\n    if (warnings.length > 0) {\n      logger.warn(`Warnings for ${testName}:`, { warnings });\n    }\n\n    return {\n      filePath: testFilePath,\n      content,\n      warnings: warnings.length > 0 ? warnings : undefined,\n      metadata: {\n        timestamp: new Date().toISOString(),\n        prompt,\n        options: opts\n      }\n    };\n  } catch (error) {\n    logger.error('Test generation failed:', { error, prompt, testName });\n    if (error instanceof TestGenerationError) {\n      throw error;\n    }\n    throw new TestGenerationError(\n      'Failed to generate test',\n      error instanceof Error ? error.message : String(error)\n    );\n  }\n}\n\n/**\n * Validates input parameters\n * @throws {TestGenerationError} If validation fails\n */\nfunction validateInputs(prompt: string, testName: string): void {\n  if (!prompt?.trim()) {\n    throw new TestGenerationError('Prompt cannot be empty');\n  }\n  if (!testName?.trim()) {\n    throw new TestGenerationError('Test name cannot be empty');\n  }\n  if (!/^[a-zA-Z0-9_-]+$/.test(testName)) {\n    throw new TestGenerationError(\n      'Test name contains invalid characters',\n      'Use only letters, numbers, underscores, and hyphens'\n    );\n  }\n}\n\n/**\n * Ensures output directory exists\n * @throws {TestGenerationError} If directory creation fails\n */\nasync function ensureOutputDirectory(outputDir: string): Promise<string> {\n  try {\n    const testDir = path.join(process.cwd(), outputDir);\n    await fs.promises.mkdir(testDir, { recursive: true });\n    return testDir;\n  } catch (error) {\n    throw new TestGenerationError(\n      'Failed to create output directory',\n      error instanceof Error ? error.message : String(error)\n    );\n  }\n}\n\n/**\n * Generates test content using AI with templates\n */\nasync function generateTestContent(\n  prompt: string,\n  options: Required<TestGeneratorOptions>\n): Promise<string> {\n  try {\n    const enhancedPrompt = `\n      Generate a Playwright test for the following scenario:\n      ${prompt}\n      \n      Requirements:\n      - Use TypeScript\n      - Include proper imports\n      - Add meaningful assertions\n      - Handle timeouts and errors\n      - Add JSDoc documentation\n      - Use page object patterns\n      - Include test metadata (title, tags)\n    `;\n\n    const baseContent = await askAI(enhancedPrompt, options.temperature);\n    if (!options.template) {\n      return baseContent;\n    }\n\n    return options.template.replace('${TEST_CONTENT}', baseContent);\n  } catch (error) {\n    throw new TestGenerationError(\n      'Failed to generate test content',\n      error instanceof Error ? error.message : String(error)\n    );\n  }\n}\n\n/**\n * Validates test syntax and patterns\n */\nfunction validateTestSyntax(content: string): string[] {\n  const warnings: string[] = [];\n  const checks: [RegExp, string][] = [\n    [/import.*@playwright\\/test/i, 'Missing Playwright test imports'],\n    [/test\\(['\"].*['\"]/i, 'No test function declarations found'],\n    [/expect\\(/i, 'No assertions found'],\n    [/beforeAll|beforeEach|afterAll|afterEach/i, 'No test hooks found'],\n    [/try\\s*{.*}\\s*catch/s, 'No error handling found'],\n    [/\\/\\*\\*[\\s\\S]*?\\*\\//i, 'Missing JSDoc documentation'],\n    [/page\\.[a-zA-Z]+/i, 'No page interactions found'],\n    [/TODO|FIXME/i, 'Contains TODO comments'],\n    [/await/i, 'No async/await usage found'],\n    [/export/i, 'Test is not exported']\n  ];\n\n  for (const [pattern, message] of checks) {\n    if (!pattern.test(content)) {\n      warnings.push(message);\n    }\n  }\n\n  return warnings;\n}\n\n/**\n * Formats the generated test code\n */\nasync function formatTestCode(content: string): Promise<string> {\n  // Add proper imports and setup\n  const header = `\n    // @ts-check\n    import { test, expect } from '@playwright/test';\n    import { chromium, Browser, BrowserContext, Page } from '@playwright/test';\n  `.trim() + '\\n\\n';\n\n  // Format content\n  const formatted = content\n    .split('\\n')\n    .map(line => line.trimEnd()) // Remove trailing spaces\n    .join('\\n')\n    .replace(/\\n{3,}/g, '\\n\\n') // Remove extra blank lines\n    .trim();\n\n  return header + formatted + '\\n';\n}\n\n/**\n * Writes the test file and metadata\n */\nasync function writeTestFile(\n  testDir: string,\n  testName: string,\n  content: string,\n  options: Required<TestGeneratorOptions>\n): Promise<string> {\n  try {\n    // Create test file\n    const testFilePath = path.join(testDir, `${testName}${options.fileExtension}`);\n    await fs.promises.writeFile(testFilePath, content, 'utf-8');\n\n    // Create metadata file\n    const metadataPath = testFilePath + '.meta.json';\n    const metadata = {\n      generatedAt: new Date().toISOString(),\n      options,\n      stats: {\n        lines: content.split('\\n').length,\n        size: Buffer.from(content).length\n      }\n    };\n    await fs.promises.writeFile(metadataPath, JSON.stringify(metadata, null, 2));\n\n    return testFilePath;\n  } catch (error) {\n    throw new TestGenerationError(\n      'Failed to write test file',\n      error instanceof Error ? error.message : String(error)\n    );\n  }\n}\n"]}